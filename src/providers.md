## Providers: Providers are a fundamental concept in Nest. Many of the basic Nest classes may be treated as a provider – services, repositories, factories, helpers, and so on. The main idea of a provider is that it can be injected as a dependency; this means objects can create various relationships with each other, and the function of "wiring up" instances of objects can largely be delegated to the Nest runtime system. In the previous chapter, we built a simple. Providers are plain JavaScript classes that are declared as in a module

- Providers: Providers là một khái niệm cơ bản trong Nest. Nhiều lớp cơ bản Nest có thể được coi là một nhà cung cấp - dịch vụ, kho lưu trữ, nhà máy, trợ giúp và nhiều hơn nữa. Ý tưởng chính của một nhà cung cấp là nó có thể được chèn như một phụ thuộc; điều này có nghĩa là các đối tượng có thể tạo các mối quan hệ với nhau, và chức năng "nối dây" các thể hiện của các đối tượng có thể được giao cho hệ thống chạy Nest. Các nhà cung cấp là các lớp JavaScript thông thường được khai báo như trong một module

## Services: Services are the most common type of provider. They are classes with a @Injectable() decorator. Services are a great way to share functionality between classes that don't necessarily know each other. For example, a LoggerService can be injected into a MailerService, which can then be injected into a UserController. The LoggerService can then be used by the MailerService and the UserController without either of them knowing about the other. Services are also a great way to organize and share business logic (or "business rules") throughout your application. Services are a great way to share functionality between classes that don't necessarily know each other. For example, a LoggerService can be injected into a MailerService, which can then be injected into a UserController. The LoggerService can then be used by the MailerService and the UserController without either of them knowing about the other. Services are also a great way to organize and share business logic (or "business rules") throughout your application.

- Dịch vụ là loại nhà cung cấp phổ biến nhất. Họ là các lớp với một trình bày @Injectable(). Dịch vụ là một cách tuyệt vời để chia sẻ chức năng giữa các lớp không nhất thiết phải biết về nhau. Ví dụ, một LoggerService có thể được chèn vào MailerService, sau đó có thể được chèn vào UserController. LoggerService có thể được sử dụng bởi MailerService và UserController mà không cần biết về nhau. Dịch vụ cũng là một cách tuyệt vời để tổ chức và chia sẻ logic kinh doanh (hoặc "quy tắc kinh doanh") trong toàn bộ ứng dụng của bạn.

## Dependency Injection: Nest is built around the strong design pattern commonly known as Dependency injection. We recommend reading a great article about this concept in the official Angular documentation. In Nest, thanks to TypeScript capabilities, it's extremely easy to manage dependencies because they are resolved just by type. In the example below, Nest will resolve the by creating and returning an instance of (or, in the normal case of a singleton, returning the existing instance if it has already been requested elsewhere). This dependency is resolved and passed to your controller's constructor (or assigned to the indicated property)

- Dependency Injection: Nest được xây dựng dựa trên mẫu thiết kế mạnh mẽ thường được biết đến như Dependency injection. Chúng tôi khuyến khích đọc một bài viết tuyệt vời về khái niệm này trong tài liệu chính thức Angular. Trong Nest, cảm ơn khả năng của TypeScript, điều quan trọng là quản lý các phụ thuộc vì chúng được giải quyết chỉ bằng cách kiểu. Trong ví dụ dưới đây, Nest sẽ giải quyết bằng cách tạo và trả về một thể hiện của (hoặc, trong trường hợp bình thường của một singleton, trả về thể hiện hiện có nếu nó đã được yêu cầu ở nơi khác). Phụ thuộc này được giải quyết và được truyền vào bộ khởi tạo của controller của bạn (hoặc được gán cho thuộc tính được chỉ định)

`constructor(private catsService: CatsService) {}`

## Scopes: Providers normally have a lifetime ("scope") synchronized with the application lifecycle. When the application is bootstrapped, every dependency must be resolved, and therefore every provider has to be instantiated. Similarly, when the application shuts down, each provider will be destroyed. However, there are ways to make your provider lifetime request-scoped as well. You can read more about these techniques here.

- Scopes: Nhà cung cấp thường có một thời gian sống ("phạm vi") được đồng bộ hóa với vòng đời ứng dụng. Khi ứng dụng được khởi chạy, mọi phụ thuộc phải được giải quyết, vì vậy mọi nhà cung cấp phải được khởi tạo. Tương tự, khi ứng dụng tắt, mỗi nhà cung cấp sẽ bị phá hủy. Tuy nhiên, có một số cách để làm cho thời gian sống của nhà cung cấp được yêu cầu cũng như vậy. Bạn có thể đọc thêm về các kỹ thuật này ở đây.
